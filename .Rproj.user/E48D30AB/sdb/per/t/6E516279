{
    "collab_server" : "",
    "contents" : "#\n#   Copyright (c) 2015 Roland Hansson - Nova Spatial LLC. All\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# library(opencpu)\n# opencpu$stop()\n# opencpu$start(9069)\n# opencpu$browse(\"/library/geotuple/www/index.html\")\n# library(RPostgreSQL)\n# library(spdep)\n#\n# .Rprofile in HOMEPATH\n# Sys.getenv('HOME')\n\n#-----------------------------------------------------------------\ninit <- function(v=\"MB_TOKEN\") {\n  return(eval(parse(text=v)))\n}\n\n#-----------------------------------------------------------------\ngetPoints <- function (sw, ne, zoom=14, style=\"val\", themes=\"z\") {\n  # getPoints( c(33.743,-117.81), c(33.75,-117.79), \"15\")\n  # getPoints( c(33.743,-117.81), c(33.75,-117.79), \"15\", \"hot\", list(\"z\"))\n  # getPoints( c(33.743,-117.81), c(33.75,-117.79), \"15\", \"val\", list(\"z\",\"landcov\"))\n  # getPoints( c(33.743,-117.81), c(33.75,-117.79), \"15\", \"hot\", list(\"z\",\"landcov\"))\n  data <- list()\n  #ptm <- proc.time()  # Start timing\n\n  # load data frame\n  if (length(themes) > 0) {\n    df <- queryDbPoints(sw, ne, zoom, themes)\n  }\n  if (length(df) > 1) {\n    if (style==\"hot\") {\n      df <- hotSpot(df)\n      data <- list(df, min(df$Getis,na.rm=T), mean(df$Getis,na.rm=T), max(df$Getis,na.rm=T))\n    } else {  # col value\n      data <- list(df, min(df[,3],na.rm=T), mean(df[,3],na.rm=T), max(df[,3],na.rm=T))\n    }\n  }\n  #print(proc.time() - ptm)  # Stop timing\n  return(data)\n}\n\n#-----------------------------------------------------------------\nqueryDbPoints <- function(sw, ne, zoom, themes) {\n  df = NULL\n\n  # build dynamic query\n  xmin <- sw[2]\n  ymin <- sw[1]\n  xmax <- ne[2]\n  ymax <- ne[1]\n  cols <- paste(themes, collapse=',')\n  if (length(themes)>1) {\n    themesl <- paste(themes, collapse=' numeric, ')\n    themesl <- paste(themesl,\"numeric\")\n  } else {\n    themesl <- paste(themes,\"numeric\")\n  }\n  defs <- paste(\"AS (x float, y float,\", themesl)\n  key <- paste(\"'\",GT_KEY,\"'\", sep = \"\")\n\n  # create a connection to the postgres database\n  con <- getPgCon()\n\n  # query for features in bnds\n  tab <- \"grid\"\n  if (dbExistsTable(con, tab)) {\n    q <- paste(\"SELECT * FROM gt_selectgridx(\", xmin,\",\",ymin,\",\",xmax,\",\",ymax,\",\",zoom,\",'{\", cols,\"}',\",key,\")\", defs,\");\")\n    #print(q)\n    df <- dbGetQuery(con, q)\n  }\n  dbDisconnect(con)\n  return(df)\n}\n\n#-----------------------------------------------------------------\nhotSpot <-function(df) {\n  #\n  # http://www.maths.lancs.ac.uk/~rowlings/Teaching/UseR2012/cheatsheet.html\n  require(spdep)\n\n  xy <- df[,c(1,2)]\n  val <- df[c(3)]\n  col = colnames(df[3])  # first theme is target\n  spdf <- SpatialPointsDataFrame(coords=xy, data=val, proj4string = CRS(\"+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0\"))\n  #View(spdf)\n  kn <- knearneigh(spdf, k=4)\n  kn <- knn2nb(kn)  # convert to nb object\n  # Test Local Getis Ord G\n  G <- localG(spdf@data[ , col ], listw=nb2listw(kn), zero.policy=TRUE)\n  # append the Z-scores back to the points\n  spdf@data$Getis <- G[1:length(G)]\n  df2 <- merge(df, as.data.frame(spdf))  # append to original\n  #View(df2)\n  return(df2)\n}\n\n#-----------------------------------------------------------------\ncompute <- function (sw, ne, zoom=14, alztype=\"cor\", themes=NULL) {\n  # df1 <- compute( c(33.743,-117.81), c(33.75,-117.79), \"15\", \"cor\", list(\"z\", \"landcov\"))\n  # df1 <- compute( c(33.743,-117.81), c(33.75,-117.79), \"15\", \"cor\", list(\"z\", \"landcov\", \"dist_mroad\"))\n  # NOTE: step 1\n  df = list()\n\n  # load data frame for subsequent analysis\n  if (length(themes) > 1) {\n    pts <- queryDbPoints(sw, ne, zoom, themes)\n    if (length(pts)>1) {\n      df <- pts\n    }\n  }\n  return(df)\n}\n\n#-----------------------------------------------------------------\ncomputeCor <- function(df) {\n  # Correlation\n  # computeCor(df1)\n  # NOTE: step 2\n  # assumes [x, y, theme1, theme2, .. n]\n  data <- list()\n  numCols <- ncol(df)\n  if (numCols < 5) {\n    Test <- cor.test(df[,c(3)], df[,c(4)], method=\"pearson\", na.action=\"na.exclude\")\n    #print(Test)\n    #str(Test)\n    m  <- Test$method\n    n  <- Test$parameter[1]\n    cc <- Test$estimate\n    pv <- Test$p.value\n    ci1 <- Test$conf.int[1]\n    ci2 <- Test$conf.int[2]\n    data <- list(\"Correlation coefficient (r)\", round(cc, digits=3), \"Method\", m, \"Degrees of freedom\", n, \"p-value\", round(pv, digits=6),\n                 \"95 percent confidence interval (1)\", ci1, \"95 percent confidence interval (2)\", ci2)\n  } else {\n    yCols <- colnames(df[,c(4:numCols)])\n    Cor <- round(cor(df[,c(3:4)], use=\"pairwise.complete.obs\", method=\"pearson\"), digits=3)\n    cc <- Cor[2]\n    avg <- abs(c(cc))\n    yVals <- c(cc)\n    yAbs <- c(avg)\n    for (i in 5:numCols) {  # all but x, y, theme1\n      Cor <- cor(df[,c(3,i)], use=\"pairwise.complete.obs\", method=\"pearson\")\n      cc <- round(Cor, digits=3)[2]\n      avg <- c(avg, abs(cc))\n      yVals <- c(yVals, cc)\n      yAbs <- c(yAbs, abs(cc))\n    }\n    dfY <-data.frame(col=yCols, val=yVals, abs=yAbs)\n    avgCC <- (mean(dfY[[\"abs\"]]))\n    #print(dfY)\n    # sort by absolute values so we can returned a ranked list of themes\n    dfYsort <- dfY[with(dfY, order(-abs)),]\n    #print(dfYsort)\n    data <- list(\"Mean correlation coeff. (r)\", round(avgCC, digits=3), \"Variables by rank\", dfYsort[[\"col\"]], \"Corr. coeffs. by rank\", dfYsort[[\"val\"]])\n  }\n  return(data)\n}\n\n#-----------------------------------------------------------------\ncomputeReg <- function(df) {\n  # Regression\n  # computeReg(df1)\n  # NOTE: step 2\n  # assumes [x, y, theme1-Y, theme2-X1, .. theme-Xn]\n  data <- list()\n  xvar <- colnames(df)[3]\n  ycols <- colnames(df[-1:-3])  # all but x, y\n  yvars <- paste(ycols, collapse=\"+\")\n  frm <- formula(paste(xvar,\"~\",yvars))\n  LM.model = lm(frm, data=df)\n  #print(summary(LM.model))\n  sumLM <- summary(LM.model)\n  #str(sumLM)\n  r2 <- sumLM$r.squared\n  ar2 <- sumLM$adj.r.squared\n  se <- sumLM$coefficients[2]\n  fs <- sumLM$fstatistic[1]\n  n <- sumLM$fstatistic[3]\n  pv <- anova(LM.model)$'Pr(>F)'[1]\n  data <- list(\"Coefficient of determination (R-squared)\", round(r2, digits=3), \"Adjusted R-squared\", round(ar2, digits=3),\n               \"Standard Error\", round(se, digits=3), \"F-Statistic\", round(fs, digits=3), \"Degrees of freedom\", n, \"p-value\", round(pv, digits=6) )\n  return(data)\n}\n\n#-----------------------------------------------------------------\nscatterPlot <- function(df, x_lab=NULL, y_lab=NULL) {\n  # assumes [x, y, theme1-Y, theme2-X1, .. theme-Xn]\n  if (ncol(df) < 5) {\n    xvar <- colnames(df)[3]\n    yvar <- colnames(df)[4]\n    if (length(x_lab) < 1) {x_lab = xvar}\n    if (length(y_lab) < 1) {y_lab = yvar}\n    frm <- formula(paste(xvar,\"~\",yvar))\n    LM.model = lm(frm, data=df)\n    #print(summary(LM.model))\n    rsq <- summary(LM.model)$r.squared\n    plot(frm, data=df, pch=20, xlab=x_lab, ylab=y_lab)\n    abline(LM.model, col=\"red\")  # Draws the regression line on the plot\n  } else {\n    # NOTE abline - http://stackoverflow.com/questions/17615791/plot-regression-line-from-multiple-regression-in-r\n    plot(df[-1:-2], pch=20)  # all but x, y\n  }\n}\n\n#-----------------------------------------------------------------\nresidualPlot <- function(df) {\n  # assumes [x, y, theme1-Y, theme2-X1, .. theme-Xn]\n  xvar <- colnames(df)[3]\n  ycols <- colnames(df[-1:-3])  # all but x, y, theme1\n  yvars <- paste(ycols, collapse=\"+\")\n  frm <- formula(paste(xvar,\"~\",yvars))\n  LM.model = lm(frm, data=df)\n  par(mfrow=c(2,2))\n  plot(LM.model, pch=20)\n}\n\n#-----------------------------------------------------------------\ngetPgCon <- function(db=PG_DB){\n  require(RPostgreSQL)\n  return(dbConnect(PostgreSQL(),\n                   host=\"localhost\",\n                   port=PG_PORT,\n                   user=PG_USER,\n                   password=PG_PASSW,\n                   dbname=db))\n}\n\n#-----------------------------------------------------------------\ngetThemes <- function(themes='*') {\n  df = NULL\n\n  # create a connection to the postgres database\n  con <- getPgCon()\n\n  # query for themes\n  tab <- \"theme\"\n  if (dbExistsTable(con, tab)) {\n    q <- paste(\"SELECT array_agg(name ORDER BY theme_id) AS themes FROM theme;\")\n    #print(q)\n    df <- dbGetQuery(con, q)\n  }\n  dbDisconnect(con)\n  return(df)\n}\n\n#-----------------------------------------------------------------\napi_getpoints <- function(sw_lon, sw_lat, ne_lon, ne_lat, zoom=7, themes='z', key=0) {\n  #                                                                                                 Sacramento:   -121.552 38.543 -121.44 38.61\n  # curl http://localhost:9069/ocpu/library/geotuple/R/api_getpoints/json -H \"Content-Type: application/json\" -d '{\"sw_lon\":\"-117.222\", \"sw_lat\":\"34.026\", \"ne_lon\":\"-117.166\", \"ne_lat\":\"34.062\", \"zoom\":\"11\", \"themes\":\"z\", \"key\":\"API_KEY\"}'\n  # curl http://localhost:9069/ocpu/library/geotuple/R/api_getpoints/json -H \"Content-Type: application/json\" -d '{\"sw_lon\":\"-117.222\", \"sw_lat\":\"34.026\", \"ne_lon\":\"-117.166\", \"ne_lat\":\"34.062\", \"zoom\":\"12\", \"themes\":[\"landcov\", \"dist_mroad\"], \"key\":\"API_KEY\"}'\n  #\n  df = NULL\n\n  # build dynamic query\n  cols <- paste(themes, collapse=',')\n  if (length(themes)>1) {\n    themesl <- paste(themes, collapse=' numeric, ')\n    themesl <- paste(themesl,\"numeric\")\n  } else {\n    themesl <- paste(themes,\"numeric\")\n  }\n  #print(themesl)\n  defs <- paste(\"AS (x float, y float,\", themesl)\n  key <- paste(\"'\", key,\"'\", sep = \"\")\n\n  # create a connection to the postgres database\n  con <- getPgCon()\n\n  # query for feature closest to lon/lat\n  tab <- \"grid\"\n  if (dbExistsTable(con, tab)) {\n    q <- paste(\"SELECT * FROM gt_api_getpoints(\", sw_lon,\",\",sw_lat,\",\",ne_lon,\",\",ne_lat,\",\", zoom,\",'{\", cols,\"}',\",key,\")\", defs,\");\")\n    #print(q)\n    df <- dbGetQuery(con, q)\n  }\n  dbDisconnect(con)\n  return(df)\n}\n\n#-----------------------------------------------------------------\napi_getpoint <- function(lon, lat, themes='z', key=0) {\n  #\n  # curl http://localhost:9069/ocpu/library/geotuple/R/api_getpoint/json -H \"Content-Type: application/json\" -d '{\"lon\":\"-117.198\", \"lat\":\"34.0402\", \"themes\":\"z\", \"key\":\"API_KEY\"}'\n  # curl http://localhost:9069/ocpu/library/geotuple/R/api_getpoint/json -H \"Content-Type: application/json\" -d '{\"lon\":\"-117.198\", \"lat\":\"34.0402\", \"themes\":[\"landcov\", \"dist_mroad\"], \"key\":\"API_KEY\"}'\n  # curl http://localhost:9069/ocpu/library/geotuple/R/api_getpoint/json -H \"Content-Type: application/json\" -d '{\"lon\":\"-117.198\", \"lat\":\"34.0402\", \"themes\":\"*\", \"key\":\"API_KEY\"}'\n  #\n  df = NULL\n\n  # build dynamic query\n  cols <- paste(themes, collapse=',')\n  if (length(themes)>1) {\n    themesl <- paste(themes, collapse=' numeric, ')\n    themesl <- paste(themesl,\"numeric\")\n  } else {\n    if (themes==\"*\") {\n      themes <- getThemes()\n      themes <- substr(themes, 2 , nchar(themes) - 1)  # trim {..}\n      themes <- strsplit(themes, \",\")\n      themesl <- list()\n      for (w in themes) {\n        themesl <- c(themesl, w)\n      }\n      themesl <- paste(themesl, collapse=' numeric, ')\n      themesl <- paste(themesl,\"numeric\")\n    } else {\n      themesl <- paste(themes,\"numeric\")\n    }\n  }\n  #print(themesl)\n  defs <- paste(\"AS (dist int,\", themesl)\n  key <- paste(\"'\",GT_KEY,\"'\", sep = \"\")\n\n  # create a connection to the postgres database\n  con <- getPgCon()\n\n  # query for feature closest to lon/lat\n  tab <- \"grid\"\n  if (dbExistsTable(con, tab)) {\n    q <- paste(\"SELECT * FROM gt_api_getpoint(\", lon,\",\",lat,\",'{\", cols,\"}',\",key,\")\", defs,\");\")\n    #print(q)\n    df <- dbGetQuery(con, q)\n  }\n  dbDisconnect(con)\n  return(df)\n}\n\n#-----------------------------------------------------------------\napi_getthemes <- function(themes='*', key=0) {\n  #\n  # curl http://localhost:9069/ocpu/library/geotuple/R/api_getthemes/json -H \"Content-Type: application/json\" -d '{\"themes\":\"*\"}'\n  #\n  df = NULL\n\n  # create a connection to the postgres database\n  con <- getPgCon()\n\n  # query for themes\n  tab <- \"theme\"\n  if (dbExistsTable(con, tab)) {\n    #q <- paste(\"SELECT array_agg(name ORDER BY theme_id) AS themes FROM theme;\")\n    q <- paste(\"SELECT name, descr FROM theme ORDER BY theme_id;\")\n    #print(q)\n    df <- dbGetQuery(con, q)\n  }\n  dbDisconnect(con)\n  return(df)\n}\n\n#-----------------------------------------------------------------\napi_getthemeprops <- function(theme) {\n  #\n  # curl http://localhost:9069/ocpu/library/geotuple/R/api_getthemeprops/json -H \"Content-Type: application/json\" -d '{\"theme\":\"z\"}'\n  #\n  df = NULL\n\n  # create a connection to the postgres database\n  con <- getPgCon()\n\n  # query for theme properties\n  tab <- \"themestat\"\n  if (dbExistsTable(con, tab)) {\n    #q <- paste(\"SELECT descr, type, units, is_dist, min, max, avg FROM theme t INNER JOIN themestat ts ON ts.theme_id = t.theme_id WHERE t.name = 'z';\")\n    q <- paste(\"SELECT descr, type, units, is_dist, min, max, avg FROM theme t INNER JOIN themestat ts ON ts.theme_id = t.theme_id WHERE t.name = \")\n    q <- paste(q, \"'\", theme, \"';\", sep = \"\")\n    #print(q)\n    df <- dbGetQuery(con, q)\n  }\n  dbDisconnect(con)\n  return(df)\n}\n\n#-----------------------------------------------------------------\ngetKey <-function (x=\"\") {\n  return(\"Generating key...\")  # the purpose is to just create a session\n}\n\n#-----------------------------------------------------------------\naddKey <- function(key=\"\") {\n  #\n  df = NULL\n\n  # create a connection to the postgres database\n  con <- getPgCon()\n\n  if (isSession(key)) {\n    q <- paste(\"select gt_addkey('\", key, \"', '\", GT_KEY, \"');\", sep = \"\")\n    #print(q)\n    x <- dbGetQuery(con, q)\n    if (!is.null(x)) {\n      df <- x\n    }\n  }\n  dbDisconnect(con)\n  return(df)\n}\n\n#-----------------------------------------------------------------\nisSession <-function (key=\"\") {\n  # hardcoded path\n  f <- paste(\"/tmp/ocpu-www-data/tmp_library/\", sep=\"\", key)\n  #f <- \"/usr/local\"\n  return((file.exists(f)))\n}\n\n#-----------------------------------------------------------------\ntest <-function (x=\"\") {\n  print(\"test\")\n  list(message = paste(x, \" \", R.Version()$version.string))\n}\n\n",
    "created" : 1482773106212.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1635825224",
    "id" : "6E516279",
    "lastKnownWriteTime" : 1485395372,
    "last_content_update" : 1485395372234,
    "path" : "~/NovaSp/GeoTuple/geotuple2x/R/geotuple.R",
    "project_path" : "R/geotuple.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}